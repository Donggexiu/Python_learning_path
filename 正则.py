#!/usr/bin/env/python_SQLAlchemy
# _*_coding:utf-8_*_
# @Time : 2018/11/12 16:58
# @Author : 小仙女
# @Site : 
# @File : 正则.py
# @Software: PyCharm
import re
# '用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以：
# '00\d'可以匹配'007'，但无法匹配'00A'；
# '\d\d\d'可以匹配'010'；
# '\w\w\d'可以匹配'py3'；
'.可以匹配任意字符，所以：'
# 'py.'可以匹配'pyc'、'pyo'、'py!'等等。
# $	匹配输入字符串的结尾位置.要匹配 $ 字符本身，请使用 \$。
# ()	标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 和。
# *	匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
# +	匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
# .	匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。
# [	标记一个中括号表达式的开始。要匹配 [，请使用 \[。
# ?	匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
# *	匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
# +	匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
# ？	匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。
# {n}   n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
# {n,}  n是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
# {n,m}	m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。

# 五，常见的正则表达式总结
# 非负整数： ^ \d +$
# 正整数： ^ [0 - 9] * [1 - 9][0 - 9] *$
# 非正整数： ^ ((-\d+) | (0 +))$
# 负整数： ^ -[0 - 9] * [1 - 9][0 - 9] *$
# 整数： ^ -?\d +$
# 非负浮点数： ^ \d + (\.\d+)?$
# 正浮点数: ^ ((0 - 9) +\.[0-9] *[1-9][0-9] *) | ([0 - 9] * [1 - 9][0 - 9] *\.[0-9]+) | ([0 - 9] * [1 - 9][0 - 9] *)$
# 非正浮点数： ^ ((-\d+\.\d+)?) | (0 + (\.0+)?))$
# 负浮点数： ^ (-((正浮点数正则式)))$
# 英文字符串： ^ [A - Za - z] +$
# 英文大写串： ^ [A - Z] +$
# 英文小写串： ^ [a - z] +$
# 英文字符数字串： ^ [A - Za - z0 - 9] +$
# 英数字加下划线串： ^ \w +$
# E - mail地址： ^ [\w -]+(\.[\w-]+) * @ [\w -]+(\.[\w-]+) +$
# URL： ^ [a - zA - Z] +: // (\w+(-\w+) *)(\.(\w+(-\w+) *))*(\?\s *)?$
# 或： ^ http:\ / \ / [A - Za - z0 - 9] +\.[A - Za - z0 - 9] + [\ /= \? % \- & _~` @ [\]\':+!]*([^<>\"\"])*$
# 邮政编码： ^ [1 - 9]\d{5}$
# 中文： ^ [\u0391 -\uFFE5]+$
# 电话号码： ^ ((\(\d{2, 3}\)) | (\d{3}\-))?(\(0\d{2, 3}\) | 0\d{2, 3} -)?[1 - 9]\d{6, 7}(\-\d{1, 4})?$
# 手机号码： ^ ((\(\d{2, 3}\)) | (\d{3}\-))?13\d{9}$
#
# 双字节字符(包括汉字在内)： ^ \x00 -\xff
#
# 匹配首尾空格：(^ \s *) | (\s * $)（像vbscript那样的trim函数）
#
# 匹配HTML标记： < (.*) >.* < \ / \1 > | < (.*) \ / >
#
# 匹配空行：\n[\s |] * \r
#
# 提取信息中的网络链接：(h | H)(r | R)(e | E)(f | F) *= *('|")?(\w|\\|\/|\.)+(' | "| *|>)?
#
# 提取信息中的邮件地址：\w+([-+.]\w+) * @\w + ([-.]\w+) *\.\w + ([-.]\w+) *
# 提取信息中的图片链接：(s | S)(r | R)(c | C) *= *('|")?(\w|\\|\/|\.)+(' | "| *|>)?

# 提取信息中的IP地址：(\d+)\.(\d+)\.(\d+)\.(\d+)
#
# 提取信息中的中国手机号码：(86) * 0 * 13\d{9}
#
# 提取信息中的中国固定电话号码：(\(\d{3, 4}\) |\d{3, 4} - |\s)?\d{8}
# 提取信息中的中国电话号码（包括移动和固定电话）：(\(\d{3, 4}\) |\d{3, 4} - |\s)?\d{7, 14}
# 提取信息中的中国邮政编码：[1 - 9]{1}(\d +){5}
# 提取信息中的浮点数（即小数）：(-?\d *)\.?\d +
# 提取信息中的任何数字 ：(-?\d *)(\.\d +)?
# IP：(\d+)\.(\d+)\.(\d+)\.(\d+)
# 电话区号： / ^ 0\d
# {2, 3}$ /
# 腾讯QQ号： ^ [1 - 9] * [1 - 9][0 - 9] *$
# 帐号(字母开头，允许5 - 16
# 字节，允许字母数字下划线)： ^ [a - zA - Z][a - zA - Z0 - 9_]{4, 15}$
# 中文、英文、数字及下划线： ^ [\u4e00 -\u9fa5_a - zA - Z0 - 9]+$
# 匹配中文字符的正则表达式： [\u4e00 -\u9fa5]
# 匹配双字节字符(包括汉字在内)：[ ^\x00 -\xff]
# 匹配空行的正则表达式：\n[\s |] * \r
# 匹配HTML标记的正则表达式： / < (.*) >.* < \ / \1 > | < (.*) \ / > /
# sql语句： ^ (select | drop | delete | create | update | insert). *$
# 匹配首尾空格的正则表达式：(^ \s *) | (\s * $)
# 匹配Email地址的正则表达式：\w + ([-+.]\w+) * @\w + ([-.]\w+) *\.\w + ([-.]\w+) *
# '.'默认匹配除\n之外的任意一个字符，若指定flagDOTALL, 则匹配任意字符，包括换行
# '^'匹配字符开头，若指定flagsMULTILINE, 这种也可以匹配上(r"^a", "\nabc\neee", flags=re.MULTILINE)
# '$'匹配字符结尾，或e.search("foo$", "bfoo\nsdfsf", flags=re.MULTILINE).group()也可以
# '*'匹配 * 号前的字符0次或多次，re.findall("ab*", "cabb3abcbbac")结果为['abb', 'ab', 'a']
# '+'匹配前一个字符1次或多次，re.findall("ab+", "ab+cd+abb+bba")结果['ab', 'abb']
# '?'匹配前一个字符1次或0次
# '{m}'匹配前一个字符m次
# '{n,m}'匹配前一个字符n到m次，re.findall("ab{1,3}", "abb abc abbcbbb")
# 结果'abb', 'ab', 'abb']
# '|'匹配 | 左或 | 右的字符，re.search("abc|ABC", "ABCBabcCD").group()
# 结果'ABC''(...)'
# 分组匹配，re.search("(abc){2}a(123|456)c", "abcabca456c").group()
# 结果abcabca456c
# '\A'只从字符开头匹配，re.search("\Aabc", "alexabc")是匹配不到的
# '\Z'匹配字符结尾，同$
# '\d'匹配数字0 - 9
# '\D'匹配非数字
# '\w'匹配[A - Za - z0 - 9]
# '\W'匹配非[A - Za - z0 - 9]
# 's'匹配空白字符、\t、\n、\r, re.search("\s+", "ab\tc1\n3").group()
# 结果'\t'
# '(?P<name>...)'
# 分组匹配
# re.search("(?P<province>[0-9]{4})(?P<city>[0-9]{2})(?P < birthday >[0-9]{4})(?P<city>[0-9]{2})(?P<birthday>[0-9]{4})","371481199306143242").groupdict("city")
# 结果{'province': '3714', 'city': '81', 'birthday': '1993'}
# 最常用的匹配语法
# re.match 从头开始匹配
# re.search 匹配包含
# re.findall 把所有匹配到的字符放到以列表中的元素返回
# re.splitall 以匹配到的字符当做列表分隔符
# re.sub  匹配字符并替换

#元字符：. ^ $ * + ? { } [ ] | ( ) \
# 元字符之转义符\
# 反斜杠后边跟元字符去除特殊功能,比如\.
# 反斜杠后边跟普通字符实现特殊功能,比如\d

# ret = re.findall('c\l','abc\le')
# print(ret)
m = re.findall(r'(ad)+','add')
print(m)
ret = re.search('(?P<id>\d{2})/(?P<name>\w{3})','23/com')
print(ret.group())#23/com
print(ret.group('id'))#23

#常用方法
# 1
re.findall('a', 'alvin yuan')
# 返回所有满足匹配条件的结果,放在列表里
# 2
re.search('a', 'alvin yuan').group()
# 函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以
# 通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。
# 3
re.match('a', 'abc').group()
# 同search,不过尽在字符串开始处进行匹
# 4
ret = re.split('[ab]', 'abcd')
# 先按'a'分割得到''和'bcd',在对''和'bcd'分别按'b'分割
print(ret)  # ['', '', 'cd']
# 5
ret = re.sub('\d', 'abc', 'alvin5yuan6', 1)
print(ret)  # alvinabcyuan6
ret = re.subn('\d', 'abc', 'alvin5yuan6')
print(ret)  # ('alvinabcyuanabc', 2)
# 6
obj = re.compile('\d{3}')
ret = obj.search('abc123eeee')
print(ret.group())  # 123

ret = re.finditer('\d', 'ds3sy4784a')
print(ret)  # <callable_iterator object at 0x10195f940>

print(next(ret).group())
print(next(ret).group())
#注意
ret = re.findall('www.(baidu|oldboy).com', 'www.oldboy.com')
print(ret)  # ['oldboy']     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可
ret = re.findall('www.(?:baidu|oldboy).com', 'www.oldboy.com')
print(ret)  # ['www.oldboy.com']
#
print(re.findall("<(?P<tag_name>\w+)>\w+</(?P=tag_name)>","<h1>hello</h1>"))
print(re.search("<(?P<tag_name>\w+)>\w+</(?P=tag_name)>","<h1>hello</h1>"))
print(re.search(r"<(\w+)>\w+</\1>","<h1>hello</h1>"))